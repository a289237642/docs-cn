Pull Request 规范
=======

### 为什么使用Pull Request工作流程？

PR是个非常不错的分享信息方法，可以帮助我们了解代码库中发生的变化。也是对我们所做工作进行同行评审的最佳方式，而无需直接配对工作的成本。

**但最终我们使用PR的主要原因是为了鼓励我们对代码存储库进行提交的质量**

当然，其中包含的提交（及其附加消息）告诉人们日后检查代码的历程。如果我们不保证这些提交的质量，就会默默地失去这种能力。

**质量差的代码可以重构，提交却永远继续。**


### 什么构成优质的PR？

优质的PR会具有以下特点：

* 以某种方式增加价值，是一项完整的工作。
* 具有反映其内部工作的主题以及有助于了解变更背景的摘要。
* 将有精心编写的提交消息，精心设计的提交可以讲述这项工作的发展历程。
* 理想情况下它会很小并且易于理解。单一提交PR通常易于提交，审核和合并。
* 包含的代码将尽可能满足团队设置的最佳惯例。

但是，PR不会在提交时结束，代码更改不会对其进行单位合并并在产生中使用。

一个好的PR应该能够轻松快速地通过同行评审系统。



提交Pull Requests
----

### 确保有可依赖的标题和摘要

PR是一个Github工作流工具，因此了解PR主题，摘要和最终讨论，不像提交历史记录那样可跟踪，这一点很重要。如果我们离开Github，我们可能会失去这个信息。

尽管如此，它们是确保快速有效地处理PR的非常有用的辅助手段。

确保PR标题可以扫描，人们将阅读附加到回购的PR列表，并且必须能够根据标题区分它们。如果可能，请包含故事/问题参考，以便审阅者可以获得任何额外的上下文。如果这是一个大型代码库，得包含对受影响子系统的引用。

使用主题中的关键字来帮助人们了解您对PR的意图，例如[WIP]表示它仍在进行中，因此不应合并。


### 如果需要，在制作PR之前重新制作

除非有充分理由不进行重新定价 - 通常是因为不止一个人在分支机构工作 - 在提交PR之前，通常最好将分支机构重新整理一下。

使用 `git rebase -i master # or other reference, eg HEAD~5`

例如：

* 将'oops, fix typo/bug' 合并到其父提交中。没有理由在PR中创建和解决bug，**除非在突出它们方面具有教育价值**。
* 为清楚起见，请重新提交提交消息。一旦提交了PR，任何提交的重写将涉及一个rebase，然后可以搞乱PR中的对话。



### 瞄准一个简洁的提交

在一个理想的世界中，你的PR将是一个小的（ish）提交，做一件事 - 在这种情况下你的生活将变得更容易，因为提交消息和PR主题/摘要是等同的。

如果您的更改包含的工作量超过单个提交中明确涵盖的工作量，则**不要**尝试将其压缩为一个。提交历史应该讲述一个故事，如果该故事很长，则可能需要多次提交才能让审阅者通过它。



### 在每次提交中很好地描述更改

提交消息对于阅读代码库历史记录的人来说非常宝贵，对于理解更改的原因至关重要。

尽量确保没有上下文或理解代码的人有足够的信息来理解变化。

在可以获得外部信息引用的地方 - 例如问题/故事ID，PR编号 - 确保它们包含在提交消息中。

请记住，您的提交消息必须经受住时间的蹂躏。尝试链接到将保持同样良好的东西 - 例如，另一个提交，而不是链接到master。

** 每个提交消息都应包括进行此提交的原因。 通常通过添加一个句子来填写“我们......”这样的形式将为历史提供一个惊人的上下文，代码改变本身不能**


### 保持小的PR

尝试仅解决一个问题或在拉取请求中添加一个功能。它越大，审查越复杂，延迟的可能性就越大。请记住，审查PR需要花时间从别人那天开始。

如果必须提交大型PR，请至少让其他人了解这一事实，并安排他们的时间进行审核并将PR合并。团队在没有警告的情况下将大量工作转移到他们的圈上是不公平的。

如果你可以将大型PR重新组合成多个较小的PR，那么就这样做。





查看Pull请求
-----

审核人员有责任确保：

* 历史提交记录非常好
* 很好的传播了更改
* 快速的执行了代码审查
* 他们从将来检查代码的，人的角度正在发生的变化

### 审稿人是提交历史的守护者

确保质量提交历史的重要性不能过分强调。这是我们所做的所有工作的历史背景，对于理解过去改变的原因至关重要。现在显而易见的是，未来2-3年不会很明显。

如果没有合适的提交历史，我们也可以将所有代码存储在以yyyy-mm-dd结尾的文件中。代码库的提交历史允许人们理解**为什么**进行了更改 - 时间，内容和位置自动显而易见。

在查看提交消息时，问问自己这个问题 - 从没有任何代码库知识的人看这个变化的角度来看 - “我理解*为什么*这个改变是什么？”

**如果PR内的任何提交不符合此标准，PR应该重新定位，直到PR为止。我们无法修复提交历史记录，这与我们重构糟糕代码或修复错误的能力不同。**

一个有用的提示只是要求提交者在提交消息中添加一个句子，完成句子“我们......”。



### 保持流动

Pull请求是我们改进的基本单位。如果PR在系统中被堵塞，无论是未审查还是未管理，它们都会阻止一项工作完成。

随着PR在系统中堵塞，合并变得更加困难，因为其他功能和修复应用于相同的代码库。这反过来会进一步降低它们的速度，并且通常会完全阻止给定代码库的进度。

流量与确保PR的质量之间存在平衡。作为审阅者，应该调用代码质量问题是否足以在代码得到改进时阻止PR。可能更简单地标记代码需要返工，并引发问题更为谨慎。

任何明显会导致错误的质量问题都应该修复。


### 我们都是评论家

为确保PR迅速流经系统，我们必须扩大PR审核流程。期望一两个人审查我们代码中的所有PR是不够的（或公平的）。对于初学者来说，每次这些人忙碌时都会造成阻挡。

希望通过上述指导方针，我们都可以开始分担成为审稿人的责任。

注意：考虑到这一点 - 如果你是第一个评论PR的人，那么你就是PR的评论员。如果你觉得你不再对PR的后续合并或关闭负责，那么在PR对话中将其标记出来，以便其他人可以担任该角色。

没有理由为什么多人不能评论PR并对其进行评论，这是值得鼓励的。


### 不要自己添加PR。

有时候很容易在PR中修复一个错误，或者修改一个符合编码标准的部分，或者只是为了使一个功能更适合你的需求。

如果你这样做，你就不再是PR的评论者了。你是合作者，因此不应合并PR。

当然可以找到一个新的审阅者，但如果需要原始提交者自己修复代码，通常更改会更快。或者如果原始PR“good enough”，将你希望看到的更改提升为单独的历程/问题，并在你自己的PR中进行返工。

### 审核人员不负责测试代码

我们都是忙碌的人，如果针对我们的代码库有许多PR，我们无法或不允许测试新代码。

我们需要假设提交者已经测试了他们的代码，以便对要合并到主人并随后发布的工作感到满意。

如果你作为审稿人怀疑PR中的工作尚未经过测试，请向提交者提出。了解他们如何测试它，如果没有，就拒绝工作。 他们可能没有机制来测试它，在这种情况下你可能需要帮助。

如果作为提交者，你知道此更改未经过全面测试，请在PR文本中突出显示，并与审阅者交谈。



## 一些有趣的链接

关于如何有效地使用提交历史作为令人难以置信的文档源的精彩文章：

* <http://mislav.uniqpath.com/2014/02/hidden-documentation/>

Github对PR的建议，它提供了一些通过github @ -syntax通知团队和同事的有用技巧。

* <https://github.com/blog/1943-how-to-write-the-perfect-pull-request> 

GOV.UK git风格指南：

* <https://github.com/alphagov/styleguides/blob/master/git.md>

一个非常好的提交消息的示例，对于一个非常混乱的更改：

* <https://github.com/gds-operations/vcloud-edge_gateway/pull/111>

关于PR的GDS建议：

* https://github.com/alphagov/styleguides/blob/master/pull-requests.md

